package disorder

import (
	"testing"
)

/*
1. A + B 问题
中文English
给出两个整数 aa 和 bb , 求他们的和。

Example
样例 1:

输入:  a = 1, b = 2
输出: 3
样例解释: 返回a+b的结果.
样例 2:

输入:  a = -1, b = 1
输出: 0
样例解释: 返回a+b的结果.
Challenge
显然你可以直接 return a + b，但是你是否可以挑战一下不这样做？（不使用++等算数运算符）

Clarification
a和b都是 32位 整数么？

是的
我可以使用位运算符么？

当然可以
Notice
你不需要从输入流读入数据，只需要根据aplusb的两个参数a和b，计算他们的和并返回就行。
*/

/*
实现思路:
单个加法位运算用二进制表示有4种情况
0 + 0 = 0, 0 + 1 = 1, 1 + 0 = 1, 1 + 1 = 10
除了1 + 1 = 10有进位以外，其他的三个操作都与异或操作结果相同
0 ^ 0 元素相同为0， 0 ^ 1 元素不同为1， 1 ^ 0 元素不同为1， 1 ^ 1 元素相同为0
那么加法的二进制表示，可以推理成--非进位的异或操作+进位操作值
进位操作值其实就是进位左移1位，其他位均为0，这种操作是&,然后左移1位
0 & 0 = 0, 0 & 1 = 0, 1 & 0= 0, 1 & 1 = 1, &跟^完美互补，进位保留，非进位为0
当a，b两个值进行相加的时候， 非进位 (a ^ b) 加上 进位 (a & b << 1)就得到最终结果，
但是还有一个问题，我们是要完成加法的二进制实现，非进位与进位的最终操作还是加法，
为了解决这个问题，可以考虑使用递归，因为a & b 操作，进位总是会越来越少的，通过递归，
直到没有进位，或者说 a & b为0，这时候直接返回a

这里以a=11(3),b=101(5)为例，非进位是011 ^ 101 = 110(6),
进位是011 & 101 << 1, 011 & 101 = 001, 001 << 1 = 10(2),
110(6) + 10(2) = 8
*/
func plus(a, b int) int {
	if b == 0 {
		return a
	}

	return plus((a ^ b), (a & b << 1))
}

// go test -v github.com/dylenfu/go-libs/disorder/lintcode -run TestPlus
func TestPlus(t *testing.T) {
	if plus(100, -100) != 0 {
		t.Fatal("plus(100, -100) != 0")
	}

	if plus(3, 4) != 7 {
		t.Fatal("plus(3, 4) != 7")
	}

	if plus(6, -2) != 4 {
		t.Fatal("plus(6, -2) != 4")
	}

	if plus(3, -8) != -5 {
		t.Fatal("plus(3, -8) != -5")
	}
}
